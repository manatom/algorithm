"""
 만약 n길이의 문자열에서 길이의 패턴이 존재하는지 알아보기 위해서 일일이 대입한다면 문자열의 한 숫자에서 출발하는 m길이의 글자까지 확인해야하기때문에 시간복잡도는 O(n*m)일 것이다.
 그런데 패턴에 있어서 몇가지를 살펴보면 더 간단한 알고리즘을 구안할 수 있다. 이를 knp알고리즘이라한다.
 ababa라는 패턴이 있다고하자. 그런데 만약 4번째(시작은 0부터)의 a에서 불일치가 났다고 생각해보자. 그런데 조금 더 살펴보면 그 이전과 그 이이전 수는 a와 b일 것이다. 이들은 패턴의 첫 두글자와
 같다. 만약 이런 정보를 알고 있다면 글자가 틀렸을때 시작한 글자의 다음 글자에서 시작하는 것이 아니라 틀린글자부터 시작하되 그이전에 ab까지는 일치하기 때문에 그 다음수부터 비교할 수 있다
 면 더 효율적으로 탐색을 할 수 있을 것이다.
 그래서 우리는 패턴에서 그 해당번째 숫자까지 일치하고 다음에 글자가 불일치했다면 다음 비교는 패턴의 어디부터 하면 될지를 미리 찾을 수 있다. 이를 실패함수라하자.
 ababa에 대해 생각해보자. 이경우 패턴의 길이가 5이므로 0부터 4까지의 실패함수를 찾아야한다. 0에서의 실패함수는 0이다. a까지 일치하고 다음에 불일치한다면 다시 0번째 부터 비교해야한다.
 1일떄 마찬가지로 0이다. 그럼 2일때를 생각해보자. 2일떄는 1이다. 왜냐면 aba의 마지막 a와 패턴의 첫글자 a가 일치하기 때문이다. 따라서pattern[:2]까지 일치하고 그 다음수가 틀렸다면 그 다음
 수는 pattern[1]부터 다시 비교를 하면 된다. 이와 같이 이어지면 패턴의 길이 O(m)의 시간복잡도만에 실패함수를 구할 수 있다.
  이제 이 실패함수를 가지고 문자열과 패턴을 비교하면 된다.  이 비교과정은 실패함수를 찾는 과정과 비슷하다. 이 경우에도 문자열과 패턴이 일치하지 않으면 실패햠수(이하 ans)의 값과 비교해
  다음 문자열을 비교하면된다. 이 경우에는 문자열의 길이의 상수배의 시간복잡도안에 이루어질 수 있다. 결국 kmp알고리즘은 두 실패함수를 구하는 과정과 문자열을 비교하는 과정의 시간복잡도
  합을 가지고 이는 O(m+n)이다.
  
  구현...
  실패함수
  실패함수를 구현하기위해 실패함수의 값들을 담을 배열을 만든다.(ans),패턴의 문자 별로 찾는다.이떄 0의 경우는 무조건 0이기 때문에 고려하지 않고 1부터 시작한다.이때 이와 비교하는 패턴
 의 문자는 j로 0부터 시작한다.
 만약 pattern[i]와 pattern[j]가 일치하지 않는다고 하자. 그렇다면 만약에 j가 0이 아니라면 pattern[j-1]번째까지는 일치한다는 뜻이다. 그렇때문에 j에 ans[j-1]을 대입한다. 그런데 j가 0이
 된다면 pattern[j]까지 같은 문자는 없다는 뜻이기 때문에 더이상 고려할 필요가 없다. 여기서 while문을 통해 ans[j-1]을 구한다는 것이 이해가 잘 안될 수도 있다. 만약에 pattern[i]와 pattern[j]
 가 일치하지않았다고 생각해보자. 그렇다면 우리는 새로운 j값을 ans[j-1]으로 둘 것이다. 그런데 그 수 마저 일치하지 않는다면 다시 그 j이전 까지는 맞았을것이므로 j에 ans[j-1]을 대입한다
 이것은 j가 0이 될떄까지, 또는 pattern[i]와 pattern[j]가 같을 때까지 반복한다.  그렇다면 j가 0이거나 j는 값이 있을 것이고 앞의 경우에 실패함수값은 0, 뒤의 경우에 실패함수 값은 j+1
 일것이다. 이런 방식으로 반복문을 돌면 패턴의 각 값에 대한 실패함수 배열을 얻을 수 있다.
 문자열 찾기
  이제 문자열을 찾아야한다. 실패함수를 찾을 떄와 마찬가지로 문자열의 각 글자만큰 반복문을 돌면된다. 문자열은 text라하자.또 패턴에서 찾는 값은 0에서 시작한다. 만약 i번째 수에 대해 
 text[i]와 pattern[j]가 같지 않다면 j가 0이 아니라면 pattern[j-1]번째까지는 일치한다는 것이기 때문에 j가 0이 아니고 pattern[i]와 pattern[j]가 일치하지 않는동안 j를 갱신한다.
 반복문에서 나왔다면 j의 값이 있을 것이다. 그렇다면 j값은 0이거나 pattern[i]와 pattern[j]가 일치할 것이다. 만약에 이들이 일치한다면 두가지 경우가 있을 수 있는데 pattern[j]가 pattern의
마지막 문자를 가르킬때와 그렇지 않을 때이다. 이것은 문자열에서 패턴을 찾았다는 것과 같은 소리이다. 그렇기 때문에 정답에 i-ㅓ+1,즉 해당 패턴이 시작된 문자열의 위치를 추가한다.그리고 j값에
ans[j]를 대입해 j번째까지 j값을 새롭게 갱신한다. 아직가 패턴의 마지막수를 가리키는 것이 아니라면 j값을 늘려 pattern의 다음값을 가리키게 한다. j가 0이고 pattern[i]와 pattern[j]가 같지
않을때는 j가 0이라 다시 처음 값을 가리키고 있기때문에 별다른 조작을 하지 않아도 된다. 이렇게 text의 길이만큼의 반복문을 돌고나면 문자열에서 패턴이 나타나는 부분들을 모두 찾을 수 있다.
"""
import sys
text = sys.stdin.readline().rstrip()
pattern = sys.stdin.readline().rstrip()
def findpi(pattern):
    ans = [0]
    j = 0
    for i in range(1,len(pattern)):
        while pattern[i] != pattern[j] and j >0:
            j = ans[j-1] #접미사가 일치하지 않으면 j에 그 전 수의 접미사를 대입
        if pattern[i] == pattern[j]:
            j +=1
        ans.append(j)
    return ans
fi = findpi(pattern)
j = 0
result = []
for i in range(len(text)):
    while text[i] != pattern[j] and j > 0:
        j = fi[j-1]
    if text[i] == pattern[j]:
        if j < len(pattern)-1:
            j += 1
        else:
            result.append(i-j+1)
            j = fi[j]
len_text = len(text)
len_pattern = len(pattern)
if result:
    print(len(result))
    print(*result)
else:
    print(0)
